### Java内存模型
##### 1、主内存和工作内存
``
Java内存模型的主要目标是定义程序中各个变量的访问规则,即在虚拟机中将变量存储到内存和从内存中取出变量这样底层细节。此处的变量与Java编程时所说的变量不一样,
指包括了实例字段、静态字段和构成数组对象的元素,但是不包括局部变量与方法参数,后者是县城私有的,不会被共享。
Java内存模型中规定了所有的变量都存储在主内存中,每条线程还有自己的工作内存,线程的工作内存中保存了该线程使用到的变量到主内存副本拷贝,线程对变量的所有操作(读取、赋值)
都必须在工作内存中进行,而不能直接读写主内存中的变量。不同线程之间无法直接访问对方工作内存中的变量,线程间变量值的传递均需要在主内存中来完成。
此处的主内存、工作内存和Java内存区域的Java堆、栈、方法区不是同一层次内存划分。
``
##### 2、内存间交互操作
``
关于主内存和工作内存之间的具体交互协议,即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节,Java内存模型定义了以下八种操作来实现：
1)、lock(锁定):作用于主内存变量,把一个变量标识为一条线程的独占状态
2)、unlock(解锁):作用于主内存变量,把一个处于锁定状态的变量释放出来,释放后的变量才可以被其他线程锁定
3)、read(读取):作用于主内存变量,将一个变量值从主内存传输到线程的工作内存中,以便随后的load动作使用
4)、load(载入):作用于工作内存的变量,它将read操作从主内存中得到的变量值放入到工作内存的变量副本中
5)、use(使用):作用于工作内存的变量,它将工作内存中的一个变量值传递给执行引擎,每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作
6)、assign(赋值):作用于工作内存的变量,它将一个从执行引擎接收到的值赋值给工作内存的变量,每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作
7)、store(存储):作用于工作内存的变量,把工作内存中的一个变量的值传递到主内存中,以便随后的write操作
8)、write(写入):作用于主内存变量,它把store操作从工作内存中一个变量的值传递到主内存的变量中
``
``
Java内存模型只要求上述操作必须按顺序执行,而没有保证必须是连续执行。也就是说read和load之间,store和write之间是可以插入其他指令的,如对主内存中
的变量a、b进行访问时,可能的顺序是read a,read b,load b,load a。Java内存模型还规定了在执行上述八种基本操作时,必须满足如下规则:
1)、不允许read和load、store和write操作之一单独出现
2)、不允许一个线程丢弃它的最近assign操作,即变量在工作内存中改变了之后必须同步到主内存中
3)、不允许一个线程无原因地(没有发生过任何assign操作)把数据从工作内存同步回主内存中
4)、一个新的变量只能在主内存中诞生,不允许在工作内存中直接使用一个未被初始化的(load和assign)变量,即就是对一个变量实施use和store操作之前,
必须先执行过了assign和load操作
5)、一个变量在同一时刻只允许一条线程对其进行lock操作,lock和unlock必须成对出现
6)、如果对一个变量执行lock操作,将会清空工作内存中此变量的值,在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值
7)、如果一个变量事先没有被lock操作锁定,则不允许对它执行unlock操作,也不允许去unlock一个被其他线程锁定的变量
8)、对一个变量执行unlock操作之前,必须先把吃变量同步到主内存中(执行store和write操作)
``
##### 3、重排序
``
在执行程序时为了提高性能,编译器和处理器经常会对指令进行重排序。重排序分成三种类型:
1)、编译器优化的重排序。编译器在不改变单线程程序语义的前提下,可以重新安排语句的执行顺序
2)、指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性,处理器可以改变语句对应机器指令的执行顺序。
3)、内存系统的重排序。由于处理器使用缓存和读写缓冲区,这使得加载和存储操作看上去可能是在乱序执行
``
``
为了保证内存的可见性,Java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。Java内存模型把内存屏障分为LoadLoad/
LoadStore/StoreLoad和StoreStore四种。
``